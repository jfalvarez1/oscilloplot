// Standalone Image Vectorizer Tool
// Separate executable to avoid freezing the main Oscilloplot app

#ifdef _WIN32
#include <windows.h>
#endif

#include "vectorizer/image_vectorizer.hpp"
#include <SDL.h>
#include <SDL_opengl.h>
#include <imgui.h>
#include <imgui_impl_sdl2.h>
#include <imgui_impl_opengl3.h>
#include <implot.h>
#include <portable-file-dialogs.h>
#include <cstdio>
#include <fstream>
#include <thread>
#include <atomic>
#include <mutex>

using namespace oscilloplot;

//==============================================================================
// Global State
//==============================================================================
static ImageVectorizer g_vectorizer;
static VectorizerParams g_params;
static std::vector<float> g_patternX;
static std::vector<float> g_patternY;
static std::string g_imagePath;
static std::string g_statusMessage = "Ready";
static float g_progress = 0.0f;
static std::atomic<bool> g_processing{false};
static std::atomic<bool> g_processingDone{false};
static std::mutex g_mutex;

// OpenGL texture for preview
static GLuint g_previewTexture = 0;
static int g_previewWidth = 0;
static int g_previewHeight = 0;

// Log file for debugging
static FILE* g_logFile = nullptr;

static void logMsg(const char* msg) {
    if (!g_logFile) {
        g_logFile = fopen("vectorizer_debug.log", "w");
    }
    if (g_logFile) {
        fprintf(g_logFile, "%s\n", msg);
        fflush(g_logFile);
    }
    // Also update status message so it shows in GUI
    g_statusMessage = msg;
}

//==============================================================================
// Processing Thread
//==============================================================================
void processImage() {
    g_processing = true;
    g_processingDone = false;
    g_progress = 0.0f;

    logMsg("Starting image processing...");

    g_progress = 0.05f;
    char buf[256];
    snprintf(buf, sizeof(buf), "Image size: %dx%d", g_vectorizer.getWidth(), g_vectorizer.getHeight());
    logMsg(buf);

    if (!g_vectorizer.hasImage()) {
        logMsg("ERROR: No image loaded!");
        g_processing = false;
        return;
    }

    g_progress = 0.1f;
    logMsg("Calling process()...");

    g_vectorizer.process(g_params);

    g_progress = 0.6f;
    logMsg("process() done, generating pattern...");

    std::vector<float> tempX, tempY;
    g_vectorizer.generatePattern(tempX, tempY, g_params);

    g_progress = 0.9f;
    snprintf(buf, sizeof(buf), "Generated %zu points", tempX.size());
    logMsg(buf);

    {
        std::lock_guard<std::mutex> lock(g_mutex);
        g_patternX = std::move(tempX);
        g_patternY = std::move(tempY);
    }

    g_progress = 1.0f;
    snprintf(buf, sizeof(buf), "Done! %zu points", g_patternX.size());
    logMsg(buf);

    g_processing = false;
    g_processingDone = true;
}

//==============================================================================
// Save Pattern to File
//==============================================================================
bool savePattern(const std::string& path) {
    std::lock_guard<std::mutex> lock(g_mutex);

    std::ofstream file(path);
    if (!file.is_open()) return false;

    file << "# Oscilloplot Pattern\n";
    file << "# Points: " << g_patternX.size() << "\n";
    file << "# Generated by Image Vectorizer Tool\n";

    for (size_t i = 0; i < g_patternX.size(); ++i) {
        file << g_patternX[i] << " " << g_patternY[i] << "\n";
    }

    return true;
}

//==============================================================================
// Main
//==============================================================================
int main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;

#ifdef _WIN32
    // Allocate console for debug output
    AllocConsole();
    freopen("CONOUT$", "w", stdout);
    freopen("CONOUT$", "w", stderr);
    printf("[DEBUG] Console allocated\n");
#endif

    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0) {
        printf("SDL_Init Error: %s\n", SDL_GetError());
        return 1;
    }

    // OpenGL settings
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);

    // Create window
    SDL_Window* window = SDL_CreateWindow(
        "Oscilloplot - Image Vectorizer",
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
        1000, 700,
        SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI
    );

    if (!window) {
        printf("SDL_CreateWindow Error: %s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    SDL_GLContext gl_context = SDL_GL_CreateContext(window);
    SDL_GL_MakeCurrent(window, gl_context);
    SDL_GL_SetSwapInterval(1);  // VSync

    // Initialize ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImPlot::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    ImGui::StyleColorsDark();
    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
    ImGui_ImplOpenGL3_Init("#version 330");

    // Processing thread handle
    std::thread processingThread;

    // Main loop
    bool running = true;
    while (running) {
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            ImGui_ImplSDL2_ProcessEvent(&event);
            if (event.type == SDL_QUIT) {
                running = false;
            }
            if (event.type == SDL_WINDOWEVENT &&
                event.window.event == SDL_WINDOWEVENT_CLOSE &&
                event.window.windowID == SDL_GetWindowID(window)) {
                running = false;
            }
        }

        // Start new frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplSDL2_NewFrame();
        ImGui::NewFrame();

        // Main window (fullscreen docked)
        ImGui::SetNextWindowPos(ImVec2(0, 0));
        int winW, winH;
        SDL_GetWindowSize(window, &winW, &winH);
        ImGui::SetNextWindowSize(ImVec2((float)winW, (float)winH));

        ImGui::Begin("Image Vectorizer", nullptr,
            ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
            ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse |
            ImGuiWindowFlags_NoBringToFrontOnFocus);

        // Left panel - Controls
        ImGui::BeginChild("Controls", ImVec2(350, 0), true);

        ImGui::Text("IMAGE VECTORIZER");
        ImGui::Separator();
        ImGui::Spacing();

        //======================================================================
        // FILE LOADING
        //======================================================================
        ImGui::Text("Load Image");
        ImGui::Separator();

        static char pathBuffer[512] = "";

        if (ImGui::Button("Browse...", ImVec2(100, 0))) {
            auto selection = pfd::open_file(
                "Select Image",
                "",
                { "Image Files", "*.png *.jpg *.jpeg *.bmp *.gif *.tga",
                  "All Files", "*" }
            ).result();

            if (!selection.empty()) {
                strncpy(pathBuffer, selection[0].c_str(), sizeof(pathBuffer) - 1);
                pathBuffer[sizeof(pathBuffer) - 1] = '\0';
            }
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(-1);
        ImGui::InputText("##Path", pathBuffer, sizeof(pathBuffer));

        bool canLoad = !g_processing && strlen(pathBuffer) > 0;
        if (!canLoad) ImGui::BeginDisabled();
        if (ImGui::Button("Load Image", ImVec2(-1, 30))) {
            if (g_vectorizer.loadImage(pathBuffer)) {
                g_imagePath = pathBuffer;
                g_statusMessage = "Loaded: " + std::to_string(g_vectorizer.getWidth()) +
                                  "x" + std::to_string(g_vectorizer.getHeight());

                // Create preview texture
                if (g_previewTexture == 0) {
                    glGenTextures(1, &g_previewTexture);
                }
                g_previewWidth = g_vectorizer.getWidth();
                g_previewHeight = g_vectorizer.getHeight();
            } else {
                g_statusMessage = "Failed to load image!";
            }
        }
        if (!canLoad) ImGui::EndDisabled();

        if (!g_imagePath.empty()) {
            ImGui::Text("Size: %dx%d", g_vectorizer.getWidth(), g_vectorizer.getHeight());
        }

        ImGui::Spacing();
        ImGui::Spacing();

        //======================================================================
        // IMAGE TYPE GUIDE
        //======================================================================
        if (ImGui::CollapsingHeader("What type of image?", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.8f, 0.8f, 0.5f, 1.0f));
            ImGui::TextWrapped("Choose the mode that best matches your image:");
            ImGui::PopStyleColor();
            ImGui::Spacing();

            // Photo modes
            ImGui::TextColored(ImVec4(0.4f, 0.8f, 1.0f, 1.0f), "PHOTOS:");
            if (ImGui::Button("General Photo", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PhotoGeneral;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Landscapes, objects, general photography\nUses Canny edge detection");

            if (ImGui::Button("Portrait / Face", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PhotoPortrait;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("People, faces, portraits\nBilateral filter smooths skin while preserving features");

            if (ImGui::Button("High Detail", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PhotoHighDetail;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Architecture, textures, detailed scenes\nCaptures maximum edge detail");

            ImGui::Spacing();

            // People detection modes
            ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.4f, 1.0f), "PEOPLE (Smart Detection):");
            if (ImGui::Button("Face Focus", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PeopleFace;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Detect face and emphasize facial features\nSkin detection + face region estimation");

            if (ImGui::Button("Headshot / Bust", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PeopleHeadshot;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Head and shoulders portrait\nFace + upper body with smooth transitions");

            if (ImGui::Button("Full Body", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PeopleFullBody;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Complete figure with face detail\nBody silhouette + facial feature emphasis");

            if (ImGui::Button("Artistic Portrait", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PeopleArtistic;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Stylized line portrait\nDoG edge detection + artistic simplification");

            ImGui::Spacing();

            // Artwork modes
            ImGui::TextColored(ImVec4(1.0f, 0.6f, 0.8f, 1.0f), "ARTWORK:");
            if (ImGui::Button("Cartoon / Anime", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::Cartoon;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Cartoons, anime, cel-shaded art\nColor quantization + edge tracing");

            if (ImGui::Button("Line Art / Sketch", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::LineArt;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pencil drawings, ink sketches, line work\nDifference of Gaussians for line detection");

            if (ImGui::Button("Pixel Art", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::PixelArt;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Pixel art, sprites, retro graphics\nPreserves sharp pixel edges");

            ImGui::Spacing();

            // Graphics modes
            ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "GRAPHICS:");
            if (ImGui::Button("Logo / Icon", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::LogoIcon;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Logos, icons, high-contrast graphics\nSimple binary threshold");

            if (ImGui::Button("Document / Text", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::Document;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Scanned documents, printed text\nAdaptive threshold for uneven lighting");

            if (ImGui::Button("Silhouette", ImVec2(-1, 0))) {
                g_params.mode = VectorizerParams::Mode::Silhouette;
                g_params.resetToDefaults();
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Solid shapes, shadows, outlines\nHigh contrast + morphological cleanup");

            ImGui::Spacing();
            ImGui::Separator();
        }

        //======================================================================
        // CURRENT MODE INFO
        //======================================================================
        {
            const char* modeNames[] = {
                "Photo - General", "Photo - Portrait", "Photo - High Detail",
                "People - Face Focus", "People - Headshot", "People - Full Body", "People - Artistic",
                "Cartoon / Anime", "Line Art / Sketch", "Pixel Art",
                "Logo / Icon", "Document / Text", "Silhouette"
            };
            int mode = static_cast<int>(g_params.mode);
            ImGui::Text("Current: %s", modeNames[mode]);

            // Show algorithm info
            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.6f, 0.6f, 0.6f, 1.0f));
            switch (g_params.mode) {
                case VectorizerParams::Mode::PhotoGeneral:
                    ImGui::TextWrapped("Algorithm: Canny edge detection (Gaussian blur + Sobel gradients + hysteresis)");
                    break;
                case VectorizerParams::Mode::PhotoPortrait:
                    ImGui::TextWrapped("Algorithm: Bilateral filter (edge-preserving smoothing) + Canny");
                    break;
                case VectorizerParams::Mode::PhotoHighDetail:
                    ImGui::TextWrapped("Algorithm: Canny with lower thresholds for maximum detail");
                    break;
                case VectorizerParams::Mode::PeopleFace:
                    ImGui::TextWrapped("Algorithm: YCbCr skin detection + face region estimation + regional Canny");
                    break;
                case VectorizerParams::Mode::PeopleHeadshot:
                    ImGui::TextWrapped("Algorithm: Skin detection + bilateral filter + face-emphasized edge detection");
                    break;
                case VectorizerParams::Mode::PeopleFullBody:
                    ImGui::TextWrapped("Algorithm: Full-body skin detection + face emphasis + silhouette extraction");
                    break;
                case VectorizerParams::Mode::PeopleArtistic:
                    ImGui::TextWrapped("Algorithm: Face detection + DoG line art + artistic simplification");
                    break;
                case VectorizerParams::Mode::Cartoon:
                    ImGui::TextWrapped("Algorithm: Color quantization + median filter + edge detection");
                    break;
                case VectorizerParams::Mode::LineArt:
                    ImGui::TextWrapped("Algorithm: Difference of Gaussians (DoG) - approximates Laplacian of Gaussian");
                    break;
                case VectorizerParams::Mode::PixelArt:
                    ImGui::TextWrapped("Algorithm: Direct threshold without blur (preserves sharp pixels)");
                    break;
                case VectorizerParams::Mode::LogoIcon:
                    ImGui::TextWrapped("Algorithm: Binary threshold for high-contrast separation");
                    break;
                case VectorizerParams::Mode::Document:
                    ImGui::TextWrapped("Algorithm: Adaptive local threshold (handles uneven lighting)");
                    break;
                case VectorizerParams::Mode::Silhouette:
                    ImGui::TextWrapped("Algorithm: High contrast threshold + morphological cleanup");
                    break;
            }
            ImGui::PopStyleColor();

            ImGui::Checkbox("Invert Image", &g_params.invert);

            ImGui::Spacing();
            if (ImGui::Button("Reset to Defaults", ImVec2(-1, 0))) {
                g_params.resetToDefaults();
            }
        }

        //======================================================================
        // PREPROCESSING
        //======================================================================
        if (ImGui::CollapsingHeader("Preprocessing", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::SliderFloat("Blur", &g_params.blurRadius, 0.0f, 5.0f, "%.1f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Reduce noise before edge detection.\nHigher = smoother but less detail.");

            ImGui::SliderFloat("Brightness", &g_params.brightness, -1.0f, 1.0f, "%.2f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Adjust overall image brightness.");

            ImGui::SliderFloat("Contrast", &g_params.contrast, 0.5f, 2.0f, "%.2f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Increase contrast for clearer edges.");
        }

        //======================================================================
        // MODE-SPECIFIC PARAMETERS
        //======================================================================
        if (ImGui::CollapsingHeader("Detection Parameters", ImGuiTreeNodeFlags_DefaultOpen)) {
            switch (g_params.mode) {
                //--------------------------------------------------------------
                // Photo modes - Canny parameters
                //--------------------------------------------------------------
                case VectorizerParams::Mode::PhotoGeneral:
                case VectorizerParams::Mode::PhotoHighDetail:
                    ImGui::SliderFloat("Low Threshold", &g_params.cannyLow, 10.0f, 150.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Weak edge threshold.\nPixels below this are ignored.");

                    ImGui::SliderFloat("High Threshold", &g_params.cannyHigh, 30.0f, 300.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Strong edge threshold.\nLow:High ratio of 1:2 to 1:3 is optimal.");

                    if (g_params.cannyLow >= g_params.cannyHigh) {
                        g_params.cannyLow = g_params.cannyHigh * 0.33f;
                    }
                    break;

                //--------------------------------------------------------------
                // Portrait mode - Bilateral + Canny
                //--------------------------------------------------------------
                case VectorizerParams::Mode::PhotoPortrait:
                    ImGui::Text("Bilateral Filter:");
                    ImGui::SliderInt("Filter Size", &g_params.bilateralD, 5, 15);
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Filter diameter.\nLarger = more smoothing.");

                    ImGui::SliderFloat("Color Sigma", &g_params.bilateralSigmaColor, 20.0f, 150.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Color similarity range.\nHigher = more colors treated as similar.");

                    ImGui::SliderFloat("Space Sigma", &g_params.bilateralSigmaSpace, 20.0f, 150.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Spatial smoothing range.\nHigher = larger smoothing area.");

                    ImGui::Separator();
                    ImGui::Text("Edge Detection:");
                    ImGui::SliderFloat("Low Threshold", &g_params.cannyLow, 10.0f, 150.0f, "%.0f");
                    ImGui::SliderFloat("High Threshold", &g_params.cannyHigh, 30.0f, 300.0f, "%.0f");
                    if (g_params.cannyLow >= g_params.cannyHigh) {
                        g_params.cannyLow = g_params.cannyHigh * 0.33f;
                    }
                    break;

                //--------------------------------------------------------------
                // People modes - Smart detection + regional processing
                //--------------------------------------------------------------
                case VectorizerParams::Mode::PeopleFace:
                case VectorizerParams::Mode::PeopleHeadshot:
                case VectorizerParams::Mode::PeopleFullBody:
                    ImGui::Text("Face Detection:");
                    ImGui::SliderFloat("Skin Sensitivity", &g_params.skinSensitivity, 0.5f, 2.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Skin color detection range.\nHigher = detect more skin tones.");

                    ImGui::SliderFloat("Min Face Size", &g_params.minFaceRatio, 0.02f, 0.2f, "%.2f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Minimum face size as % of image.\nSmaller = detect distant faces.");

                    ImGui::Checkbox("Detect Multiple Faces", &g_params.detectMultipleFaces);
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Find all faces or just the largest.");

                    ImGui::Separator();
                    ImGui::Text("Regional Processing:");
                    ImGui::SliderFloat("Face Emphasis", &g_params.faceEmphasis, 1.0f, 3.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Detail enhancement in face region.\nHigher = more facial detail.");

                    ImGui::SliderFloat("Background Simplify", &g_params.backgroundSimplify, 1.0f, 5.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Simplification of non-face areas.\nHigher = simpler background.");

                    ImGui::Separator();
                    ImGui::Text("Edge Detection:");
                    ImGui::SliderFloat("Low Threshold", &g_params.cannyLow, 10.0f, 150.0f, "%.0f");
                    ImGui::SliderFloat("High Threshold", &g_params.cannyHigh, 30.0f, 300.0f, "%.0f");
                    if (g_params.cannyLow >= g_params.cannyHigh) {
                        g_params.cannyLow = g_params.cannyHigh * 0.33f;
                    }
                    break;

                case VectorizerParams::Mode::PeopleArtistic:
                    ImGui::Text("Face Detection:");
                    ImGui::SliderFloat("Skin Sensitivity", &g_params.skinSensitivity, 0.5f, 2.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Skin color detection range.");

                    ImGui::SliderFloat("Face Emphasis", &g_params.faceEmphasis, 1.5f, 4.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Artistic emphasis on face region.");

                    ImGui::Separator();
                    ImGui::Text("Line Art (DoG):");
                    ImGui::SliderFloat("Fine Detail", &g_params.dogSigma1, 0.5f, 2.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Inner blur for fine lines.");

                    ImGui::SliderFloat("Coarse Detail", &g_params.dogSigma2, 1.0f, 4.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Outer blur for line detection.");

                    if (g_params.dogSigma2 <= g_params.dogSigma1) {
                        g_params.dogSigma2 = g_params.dogSigma1 * 2.0f;
                    }

                    ImGui::SliderFloat("Line Threshold", &g_params.lineThreshold, 5.0f, 40.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Sensitivity for line detection.");
                    break;

                //--------------------------------------------------------------
                // Cartoon mode - Color quantization
                //--------------------------------------------------------------
                case VectorizerParams::Mode::Cartoon:
                    ImGui::SliderInt("Color Levels", &g_params.colorLevels, 2, 16);
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Number of color levels.\nFewer = more cartoon-like.");

                    ImGui::SliderFloat("Edge Threshold", &g_params.threshold, 10.0f, 100.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Threshold for detecting color boundaries.");
                    break;

                //--------------------------------------------------------------
                // Line art mode - Difference of Gaussians
                //--------------------------------------------------------------
                case VectorizerParams::Mode::LineArt:
                    ImGui::SliderFloat("Fine Detail (Sigma 1)", &g_params.dogSigma1, 0.5f, 3.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Inner Gaussian blur.\nSmaller = finer line detection.");

                    ImGui::SliderFloat("Coarse Detail (Sigma 2)", &g_params.dogSigma2, 1.0f, 6.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Outer Gaussian blur.\nShould be > Sigma 1. Ratio of 2:1 is typical.");

                    // Enforce sigma2 > sigma1
                    if (g_params.dogSigma2 <= g_params.dogSigma1) {
                        g_params.dogSigma2 = g_params.dogSigma1 * 2.0f;
                    }

                    ImGui::SliderFloat("Line Threshold", &g_params.lineThreshold, 5.0f, 50.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Threshold for line detection.\nLower = more sensitive.");
                    break;

                //--------------------------------------------------------------
                // Pixel art & Logo/Icon - Simple threshold
                //--------------------------------------------------------------
                case VectorizerParams::Mode::PixelArt:
                case VectorizerParams::Mode::LogoIcon:
                case VectorizerParams::Mode::Silhouette:
                    ImGui::SliderFloat("Threshold", &g_params.threshold, 0.0f, 255.0f, "%.0f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Binary threshold.\nPixels above = white, below = black.");
                    break;

                //--------------------------------------------------------------
                // Document mode - Adaptive threshold
                //--------------------------------------------------------------
                case VectorizerParams::Mode::Document:
                    ImGui::SliderInt("Block Size", &g_params.adaptiveBlockSize, 3, 51);
                    if (g_params.adaptiveBlockSize % 2 == 0) g_params.adaptiveBlockSize++;
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Size of local neighborhood.\nLarger = smoother threshold adaptation.");

                    ImGui::SliderFloat("Constant C", &g_params.adaptiveC, -10.0f, 15.0f, "%.1f");
                    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Offset from local mean.\nHigher = more aggressive edge detection.");
                    break;
            }
        }

        //======================================================================
        // CONTOUR PROCESSING
        //======================================================================
        if (ImGui::CollapsingHeader("Contour Processing", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::SliderInt("Min Length", &g_params.minContourLength, 3, 100);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Minimum points per contour.\nFilters out noise and tiny artifacts.");

            ImGui::SliderFloat("Simplify", &g_params.simplifyEpsilon, 0.5f, 10.0f, "%.1f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Douglas-Peucker simplification.\nHigher = fewer points, less detail.");

            ImGui::SliderFloat("Connect Dist", &g_params.connectDistance, 0.0f, 20.0f, "%.1f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Max gap to bridge between contours.\nReduces beam jumps in output.");

            ImGui::Checkbox("Close Contours", &g_params.closedContours);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Connect endpoints of nearly-closed shapes.");
        }

        //======================================================================
        // OUTPUT
        //======================================================================
        if (ImGui::CollapsingHeader("Output", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::SliderInt("Max Points", &g_params.maxOutputPoints, 1000, 20000);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Maximum points in output pattern.\nMore points = higher resolution but slower playback.");
        }

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        //======================================================================
        // PROCESS BUTTON
        //======================================================================
        bool hasImage = g_vectorizer.hasImage();
        bool canProcess = hasImage && !g_processing;

        if (!canProcess) ImGui::BeginDisabled();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.6f, 0.9f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.7f, 1.0f, 1.0f));
        if (ImGui::Button("Process Image", ImVec2(-1, 40))) {
            // Start processing in background thread
            if (processingThread.joinable()) {
                processingThread.join();
            }
            processingThread = std::thread(processImage);
        }
        ImGui::PopStyleColor(2);
        if (!canProcess) ImGui::EndDisabled();

        // Progress bar
        if (g_processing) {
            ImGui::ProgressBar(g_progress, ImVec2(-1, 0));
        }

        ImGui::Spacing();

        //======================================================================
        // SAVE BUTTON
        //======================================================================
        bool canSave = !g_patternX.empty() && !g_processing;
        if (!canSave) ImGui::BeginDisabled();
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2f, 0.7f, 0.3f, 1.0f));
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.3f, 0.8f, 0.4f, 1.0f));
        if (ImGui::Button("Save Pattern...", ImVec2(-1, 35))) {
            auto dest = pfd::save_file(
                "Save Pattern",
                "pattern.txt",
                { "Text Files", "*.txt", "All Files", "*" }
            ).result();

            if (!dest.empty()) {
                if (savePattern(dest)) {
                    g_statusMessage = "Saved to: " + dest;
                } else {
                    g_statusMessage = "Failed to save!";
                }
            }
        }
        ImGui::PopStyleColor(2);
        if (!canSave) ImGui::EndDisabled();

        ImGui::Spacing();
        ImGui::Separator();

        // Status
        ImGui::TextWrapped("Status: %s", g_statusMessage.c_str());

        // Stats
        {
            std::lock_guard<std::mutex> lock(g_mutex);
            if (!g_patternX.empty()) {
                ImGui::Text("Pattern: %zu points", g_patternX.size());
                ImGui::Text("Contours: %zu", g_vectorizer.getContours().size());
            }
        }

        ImGui::EndChild();

        ImGui::SameLine();

        // Right panel - Preview
        ImGui::BeginChild("Preview", ImVec2(0, 0), true);

        ImGui::Text("Preview");
        ImGui::Separator();

        // Draw the pattern preview using ImPlot
        float previewSize = ImGui::GetContentRegionAvail().x - 20;
        if (previewSize < 200) previewSize = 200;

        if (ImPlot::BeginPlot("##PatternPreview", ImVec2(previewSize, previewSize),
                              ImPlotFlags_Equal | ImPlotFlags_NoLegend)) {
            ImPlot::SetupAxes("X", "Y", ImPlotAxisFlags_NoTickLabels, ImPlotAxisFlags_NoTickLabels);
            ImPlot::SetupAxisLimits(ImAxis_X1, -1.1, 1.1, ImGuiCond_Always);
            ImPlot::SetupAxisLimits(ImAxis_Y1, -1.1, 1.1, ImGuiCond_Always);

            // Draw pattern
            {
                std::lock_guard<std::mutex> lock(g_mutex);
                if (!g_patternX.empty()) {
                    ImPlot::PushStyleColor(ImPlotCol_Line, ImVec4(0.4f, 1.0f, 0.3f, 1.0f));
                    ImPlot::PlotLine("Pattern", g_patternX.data(), g_patternY.data(),
                                    static_cast<int>(g_patternX.size()));
                    ImPlot::PopStyleColor();
                }
            }

            ImPlot::EndPlot();
        }

        ImGui::Spacing();
        ImGui::TextWrapped("Tip: After processing, click 'Save Pattern' to export. "
                          "Then load the .txt file in Oscilloplot using File > Load Pattern.");

        ImGui::EndChild();

        ImGui::End();

        // Render
        ImGui::Render();
        int display_w, display_h;
        SDL_GL_GetDrawableSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        SDL_GL_SwapWindow(window);
    }

    // Cleanup
    if (processingThread.joinable()) {
        processingThread.join();
    }

    if (g_previewTexture) {
        glDeleteTextures(1, &g_previewTexture);
    }

    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    ImPlot::DestroyContext();
    ImGui::DestroyContext();

    SDL_GL_DeleteContext(gl_context);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
